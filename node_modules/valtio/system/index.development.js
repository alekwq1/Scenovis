System.register(['react', 'proxy-compare', 'use-sync-external-store/shim', 'valtio/vanilla'], (function (exports) {
  'use strict';
  var useRef, useCallback, useMemo, useEffect, useDebugValue, isChanged, createProxy, affectedToPathList, useSyncExternalStore, subscribe, snapshot, getVersion;
  return {
    setters: [function (module) {
      useRef = module.useRef;
      useCallback = module.useCallback;
      useMemo = module.useMemo;
      useEffect = module.useEffect;
      useDebugValue = module.useDebugValue;
    }, function (module) {
      isChanged = module.isChanged;
      createProxy = module.createProxy;
      affectedToPathList = module.affectedToPathList;
    }, function (module) {
      useSyncExternalStore = module.useSyncExternalStore;
    }, function (module) {
      subscribe = module.subscribe;
      snapshot = module.snapshot;
      getVersion = module.getVersion;
      exports({ getVersion: module.getVersion, proxy: module.proxy, ref: module.ref, snapshot: module.snapshot, subscribe: module.subscribe, unstable_getHandler: module.getHandler });
    }],
    execute: (function () {

      exports('useSnapshot', useSnapshot);

      const useAffectedDebugValue = (state, affected) => {
        const pathList = useRef();
        useEffect(() => {
          pathList.current = affectedToPathList(state, affected);
        });
        useDebugValue(pathList.current);
      };
      function useSnapshot(proxyObject, options) {
        const affected = /* @__PURE__ */ new WeakMap();
        const lastAffected = useRef();
        const lastCallback = useRef();
        const notifyInSync = options == null ? void 0 : options.sync;
        const currSnapshot = useSyncExternalStore(useCallback((callback) => {
          lastCallback.current = callback;
          const unsub = subscribe(proxyObject, callback, notifyInSync);
          return () => {
            unsub();
            lastCallback.current = void 0;
          };
        }, [proxyObject, notifyInSync]), useMemo(() => {
          let prevSnapshot;
          return () => {
            const nextSnapshot = snapshot(proxyObject);
            try {
              if (prevSnapshot && lastAffected.current && !isChanged(prevSnapshot, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
                return prevSnapshot;
              }
            } catch (e) {
            }
            return prevSnapshot = nextSnapshot;
          };
        }, [proxyObject]));
        const currVersion = getVersion(proxyObject);
        useEffect(() => {
          lastAffected.current = affected;
          if (currVersion !== getVersion(proxyObject)) {
            if (lastCallback.current) {
              lastCallback.current();
            } else if (typeof process === "object" && process.env.NODE_ENV !== "production") {
              console.warn("[Bug] last callback is undefined");
            }
          }
        });
        {
          useAffectedDebugValue(currSnapshot, affected);
        }
        const proxyCache = useMemo(() => /* @__PURE__ */ new WeakMap(), []);
        return createProxy(currSnapshot, affected, proxyCache);
      }

    })
  };
}));
